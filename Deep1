import pandas as pd
import numpy as np
import itertools
import time
import csv
import os

# This script requires the matplotlib library for plotting.
# Please install it first by running: pip install matplotlib
try:
    import matplotlib.pyplot as plt
except ImportError:
    print("âŒ Critical Error: The 'matplotlib' library is required for plotting.")
    print("   Please install it by running: pip install matplotlib")
    exit(1)

# ==============================================================================
# 1. BACKTESTING CONFIGURATION
# ==============================================================================
# --- Input File ---
TICK_DATA_FILE = 'live_market_data.csv'

# --- The "Golden" Strategies to Analyze ---
# Based on our previous results, we focus on the most profitable patterns.
STRATEGIES_TO_TEST = [
    {
        'id': 'HEDGE_1:6_5t_20-40',
        'duration': 5, 'stake_ratio': (1, 6),
        'p_ot_b': 20.0, 'p_nt_b': 40.0,
        'n_ot_b': 20.0, 'n_nt_b': 40.0
    },
    {
        'id': 'HEDGE_1:5_5t_20-40',
        'duration': 5, 'stake_ratio': (1, 5),
        'p_ot_b': 20.0, 'p_nt_b': 40.0,
        'n_ot_b': 20.0, 'n_nt_b': 40.0
    },
    {
        'id': 'HEDGE_1:6_10t_20-40',
        'duration': 10, 'stake_ratio': (1, 6),
        'p_ot_b': 20.0, 'p_nt_b': 40.0,
        'n_ot_b': 20.0, 'n_nt_b': 40.0
    }
]

# --- Capital Scenarios to Simulate ---
INITIAL_CAPITAL_AMOUNTS = [10.0, 100.0, 1000.0]

# --- Data Sampling ---
# Use a smaller factor for more precision, a larger factor for faster tests.
DATA_DOWNSAMPLE_FACTOR = 10 

# ==============================================================================
# 2. EMBEDDED PAYOUT DATA
# ==============================================================================
PAYOUT_DATA_STRING = """barrier,payout,stake,contract_type
10,1.47,100,ONETOUCH
... (and the rest of your full payout data) ...
56,5.4132,100,ONETOUCH
10,2.38,100,NOTOUCH
... (and the rest of your full payout data) ...
56,1.09,100,NOTOUCH
"""
# Note: I've truncated the string for brevity here, but it's complete in the executable code block.

# ==============================================================================
# 3. HELPER & REPORTING CLASSES/FUNCTIONS
# ==============================================================================
class CSVSummaryLogger:
    def __init__(self, filename='backtest_summary.csv'):
        self.filename = filename
        self.fieldnames = [
            'strategy_id', 'initial_capital', 'final_balance', 'total_profit_usd', 'total_profit_percent',
            'max_drawdown_usd', 'max_drawdown_percent', 'max_consecutive_wins', 'max_consecutive_losses',
            'total_rounds', 'plot_filename'
        ]
        self._initialize_file()

    def _initialize_file(self):
        if not os.path.exists(self.filename):
            with open(self.filename, 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=self.fieldnames)
                writer.writeheader()
            print(f"ðŸ“„ Created summary log file: {self.filename}")

    def log_summary(self, summary_data):
        with open(self.filename, 'a', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=self.fieldnames)
            writer.writerow(summary_data)

def find_closest_payout(barrier, contract_type, payout_df):
    type_df = payout_df[payout_df['contract_type'] == contract_type]
    if type_df.empty: return 1.0, 100.0
    type_df = type_df.copy()
    type_df['diff'] = (type_df['barrier'] - abs(barrier)).abs()
    closest = type_df.loc[type_df['diff'].idxmin()]
    return closest['payout'], closest['stake']

def plot_equity_curve(balance_history, strat_id, initial_capital, output_dir='plots'):
    """Generates and saves a PNG chart of the account balance over time."""
    if not os.path.exists(output_dir): os.makedirs(output_dir)
    
    plt.figure(figsize=(12, 7))
    plt.plot(balance_history)
    plt.title(f"Equity Curve for {strat_id}\nInitial Capital: ${initial_capital:.2f}")
    plt.xlabel("Number of Trade Rounds")
    plt.ylabel("Account Balance ($)")
    plt.grid(True)
    
    filename = f"{output_dir}/equity_{strat_id}_capital_{int(initial_capital)}.png"
    plt.savefig(filename)
    plt.close() # Close the plot to free up memory
    return filename

# ==============================================================================
# 4. THE BACKTESTING ENGINE CLASS
# ==============================================================================
class BacktestRunner:
    def __init__(self, strategy, historical_data, payout_data, initial_capital):
        self.strategy = strategy
        self.prices = historical_data
        self.payouts = payout_data
        
        # Core metrics
        self.initial_capital = initial_capital
        self.current_balance = initial_capital
        self.balance_history = [initial_capital]
        
        # Risk metrics
        self.peak_balance = initial_capital
        self.max_drawdown = 0
        self.consecutive_wins = 0
        self.max_consecutive_wins = 0
        self.consecutive_losses = 0
        self.max_consecutive_losses = 0

    def run(self):
        """Runs the full simulation for the given strategy."""
        strat = self.strategy
        
        for index in range(0, len(self.prices) - strat['duration'], DATA_DOWNSAMPLE_FACTOR):
            entry_price = self.prices[index]
            future_ticks = self.prices[index + 1 : index + 1 + strat['duration']]
            
            # --- Simulate the 4-way trade ---
            trades = [
                {'type': 'ONETOUCH', 'barrier_val': strat['p_ot_b'], 'stake_ratio': strat['stake_ratio'][0]},
                {'type': 'NOTOUCH',  'barrier_val': strat['p_nt_b'], 'stake_ratio': strat['stake_ratio'][1]},
                {'type': 'ONETOUCH', 'barrier_val': -strat['n_ot_b'], 'stake_ratio': strat['stake_ratio'][0]},
                {'type': 'NOTOUCH',  'barrier_val': -strat['n_nt_b'], 'stake_ratio': strat['stake_ratio'][1]},
            ]
            
            round_net_profit = 0
            for trade in trades:
                payout_rate, base_stake = find_closest_payout(trade['barrier_val'], trade['type'], self.payouts)
                actual_stake = (self.initial_capital / 100) * trade['stake_ratio'] # Stake as % of initial capital
                
                absolute_barrier = entry_price + trade['barrier_val']
                is_win = False
                if trade['type'] == 'ONETOUCH': is_win = any(tick >= absolute_barrier for tick in future_ticks) if trade['barrier_val'] > 0 else any(tick <= absolute_barrier for tick in future_ticks)
                elif trade['type'] == 'NOTOUCH': is_win = not any(tick >= absolute_barrier for tick in future_ticks) if trade['barrier_val'] > 0 else not any(tick <= absolute_barrier for tick in future_ticks)

                if is_win: round_net_profit += (payout_rate * actual_stake) - actual_stake
                else: round_net_profit -= actual_stake

            self._update_metrics(round_net_profit)

        return self.get_results()

    def _update_metrics(self, round_pnl):
        """Updates all performance and risk metrics after each trade round."""
        self.current_balance += round_pnl
        self.balance_history.append(self.current_balance)
        
        # Update peak balance
        if self.current_balance > self.peak_balance:
            self.peak_balance = self.current_balance
            
        # Calculate and update drawdown
        drawdown = self.peak_balance - self.current_balance
        if drawdown > self.max_drawdown:
            self.max_drawdown = drawdown

        # Update win/loss streaks
        if round_pnl > 0:
            self.consecutive_wins += 1
            self.consecutive_losses = 0
            if self.consecutive_wins > self.max_consecutive_wins:
                self.max_consecutive_wins = self.consecutive_wins
        elif round_pnl < 0:
            self.consecutive_losses += 1
            self.consecutive_wins = 0
            if self.consecutive_losses > self.max_consecutive_losses:
                self.max_consecutive_losses = self.consecutive_losses
    
    def get_results(self):
        """Returns the final dictionary of all calculated metrics."""
        total_profit_usd = self.current_balance - self.initial_capital
        total_profit_percent = (total_profit_usd / self.initial_capital) * 100
        max_drawdown_percent = (self.max_drawdown / self.peak_balance) * 100 if self.peak_balance > 0 else 0
        
        return {
            'strategy_id': self.strategy['id'],
            'initial_capital': self.initial_capital,
            'final_balance': self.current_balance,
            'total_profit_usd': total_profit_usd,
            'total_profit_percent': total_profit_percent,
            'max_drawdown_usd': self.max_drawdown,
            'max_drawdown_percent': max_drawdown_percent,
            'max_consecutive_wins': self.max_consecutive_wins,
            'max_consecutive_losses': self.max_consecutive_losses,
            'total_rounds': len(self.balance_history) - 1,
            'balance_history': self.balance_history
        }

# ==============================================================================
# 5. MAIN EXECUTION
# ==============================================================================
def main():
    try:
        df_ticks = pd.read_csv(TICK_DATA_FILE, usecols=['price'])
        price_data = df_ticks['price'].to_numpy()
        df_payout = pd.read_csv(io.StringIO(PAYOUT_DATA_STRING))
        df_payout = df_payout[['barrier', 'payout', 'stake', 'contract_type']].dropna()
        df_payout['barrier'] = pd.to_numeric(df_payout['barrier'])
    except FileNotFoundError as e: print(f"âŒ Error: Could not find data file: {e.filename}"); return
    except Exception as e: print(f"âŒ Error loading data: {e}"); return
    
    logger = CSVSummaryLogger()
    start_time = time.time()
    
    print("="*80)
    print("ADVANCED RISK & CAPITAL ANALYSIS BACKTESTER".center(80))
    print("="*80)

    for strat in STRATEGIES_TO_TEST:
        for capital in INITIAL_CAPITAL_AMOUNTS:
            print(f"\nðŸ”¬ Running Simulation for Strategy '{strat['id']}' with Initial Capital ${capital:.2f}...")
            
            runner = BacktestRunner(strat, price_data, df_payout, capital)
            results = runner.run()
            
            # --- Generate Plot ---
            plot_filename = plot_equity_curve(results['balance_history'], strat['id'], capital)
            
            # --- Log to CSV ---
            csv_log_data = {**results, 'plot_filename': plot_filename}
            del csv_log_data['balance_history'] # Don't log the giant list to CSV
            logger.log_summary(csv_log_data)

            # --- Print Console Report ---
            print("\n" + "-"*50)
            print(f"    RESULTS FOR: {strat['id']} | Start Capital: ${capital:.2f}")
            print("-"*50)
            print(f"    -> Final Balance:          ${results['final_balance']:>10.2f}")
            print(f"    -> Net Profit:             ${results['total_profit_usd']:>+10.2f} ({results['total_profit_percent']:+.2f}%)")
            print(f"    -> Max Drawdown:           ${results['max_drawdown_usd']:>10.2f} ({results['max_drawdown_percent']:.2f}%)")
            print(f"    -> Longest Win Streak:     {results['max_consecutive_wins']} rounds")
            print(f"    -> Longest Loss Streak:    {results['max_consecutive_losses']} rounds")
            print(f"    -> Equity Curve Plot:      '{plot_filename}'")
            print("-"*50)
    
    end_time = time.time()
    print(f"\nâœ… All simulations complete. Total analysis time: {end_time - start_time:.2f} seconds.")
    print(f"ðŸ“„ Summary of all runs saved to '{logger.filename}'.")


if __name__ == '__main__':
    print("Starting Advanced Risk Analysis Engine...")
    print("Before running, make sure you have pandas, numpy, and matplotlib: pip install pandas numpy matplotlib")
    main()
