import json
import threading
import time
from collections import deque
import numpy as np
import sqlite3
import os
from datetime import datetime, timezone

# ==============================================================================
# 1. THE CAMPAIGN CONTROL PANEL
# ==============================================================================
# Define the entire series of experiments the bot will run sequentially.
EXPERIMENT_CAMPAIGN = [
    {
        'name': 'HEDGE_UPWARD_1',
        'type': 'HEDGE',
        'target_trades': 1000,
        'params': {'stake_ot': 1.00, 'stake_nt': 3.50, 'barrier_ot': "+21.00", 'barrier_nt': "+35.00"}
    },
    {
        'name': 'STRADDLE_VOLATILITY_1',
        'type': 'STRADDLE',
        'target_trades': 1000,
        'params': {'stake': 1.00, 'barrier': "+30.00"}
    },
    {
        'name': 'CHANNEL_STABILITY_1',
        'type': 'CHANNEL',
        'target_trades': 1000,
        'params': {'stake': 1.00, 'barrier': "+10.00"}
    }
]

# ==============================================================================
# 2. VOLATILITY & TECHNICAL ANALYSIS CONFIGURATION
# ==============================================================================
VOLATILITY_THRESHOLDS = {
    'VERY_LOW': 10.0, 'LOW': 20.0, 'MEDIUM': 30.0, 'HIGH': 40.0, 'VERY_HIGH': float('inf')
}
TICK_HISTORY_SIZE = 50 

# --- Library Import ---
try:
    from websocket import WebSocketApp
except ImportError:
    print("‚ùå Critical Error: The 'websocket-client' library is not installed correctly."); exit(1)

# ==============================================================================
# 3. TECHNICAL ANALYSIS MODULE
# ==============================================================================
class TechnicalAnalyzer:
    @staticmethod
    def sma(data, period):
        if len(data) < period: return None
        return sum(data[-period:]) / period

    @staticmethod
    def bollinger_bands(data, period=20, std_devs=2):
        if len(data) < period: return None, None, None
        middle_band = TechnicalAnalyzer.sma(data, period)
        if middle_band is None: return None, None, None
        std = np.std(data[-period:])
        upper_band = middle_band + (std * std_devs)
        lower_band = middle_band - (std * std_devs)
        return upper_band, middle_band, lower_band
        
    @staticmethod
    def get_price_position(price, bands):
        upper, middle, lower = bands
        if upper is None: return "NO_DATA"
        if price > upper: return "ABOVE_UPPER"
        if price > middle: return "ABOVE_MIDDLE"
        if price < lower: return "BELOW_LOWER"
        if price < middle: return "BELOW_MIDDLE"
        return "WITHIN_MIDDLE"

# ==============================================================================
# 4. ROBUST SQLITE LOGGER
# ==============================================================================
class SQLiteLogger:
    def __init__(self, db_name='deriv_analysis_data.db'):
        self.db_name = db_name
        self.conn = sqlite3.connect(db_name)
        self.cursor = self.conn.cursor()
        self._initialize_table()

    def _initialize_table(self):
        """Create the main data table if it doesn't already exist."""
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS trades (
                timestamp_utc TEXT,
                experiment_name TEXT,
                trade_pair_id TEXT,
                volatility_score REAL,
                volatility_group TEXT,
                trend_sma_fast REAL,
                trend_sma_slow REAL,
                bb_upper REAL,
                bb_middle REAL,
                bb_lower REAL,
                price_position_vs_bands TEXT,
                contract_type TEXT,
                stake REAL,
                barrier TEXT,
                potential_profit REAL,
                actual_profit REAL,
                result TEXT
            )
        ''')
        self.conn.commit()
        print(f"üìÑ Database logger initialized. Data will be saved to '{self.db_name}'.")

    def log_trade(self, trade_data):
        """Inserts a single trade record into the database."""
        columns = ', '.join(trade_data.keys())
        placeholders = ', '.join('?' * len(trade_data))
        sql = f'INSERT INTO trades ({columns}) VALUES ({placeholders})'
        self.cursor.execute(sql, tuple(trade_data.values()))
        self.conn.commit()

    def close(self):
        self.conn.close()

# --- Bot Class Definition ---
class DerivDataCollectorBot:
    def __init__(self, api_key, experiment_config, logger):
        self.api_key=api_key; self.experiment=experiment_config; self.logger=logger
        self.ws=None; self.request_id=1; self.is_running=True
        self.is_connected=False; self.is_authorized=False; self.state="INITIALIZING"
        self.trade_in_progress=False; self.active_contracts={}; self.current_proposals={}
        self.trade_pair_id_counter=0
        self.tick_history=deque(maxlen=TICK_HISTORY_SIZE)
        self.last_analysis_data={}

    def connect(self):
        print("üîå Attempting to connect..."); self.is_connected = False
        self.ws = WebSocketApp("wss://ws.binaryws.com/websockets/v3?app_id=1089", on_open=self.on_open, on_message=self.on_message, on_error=self.on_error, on_close=self.on_close)
        threading.Thread(target=self.ws.run_forever, daemon=True).start()
    
    def send(self, data):
        if self.ws and self.is_connected: data['req_id'] = self.request_id; self.request_id += 1; self.ws.send(json.dumps(data))
    
    def on_open(self, ws): print("üîó Connected."); self.is_connected = True; self.authorize()
    def on_error(self, ws, error): print(f"‚ùå WebSocket error: {error}"); self.is_connected = False
    def on_close(self, ws, close_status_code=None, close_msg=None): print("üîå Connection closed."); self.is_authorized = False; self.is_connected = False
    def authorize(self): print("üîê Authorizing..."); self.send({"authorize": self.api_key})

    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            msg_type = data.get('msg_type')
            if msg_type == 'authorize': self.handle_authorization(data)
            elif msg_type == 'tick': self.handle_tick(data)
            elif msg_type == 'proposal': self.handle_proposal(data)
            elif msg_type == 'buy': self.handle_buy(data)
            elif msg_type == 'proposal_open_contract': self.handle_contract_update(data.get('proposal_open_contract'))
            if 'error' in data and data.get('error', {}).get('code') not in ['MarketIsClosed', 'InvalidBarrier']: print(f"‚ùóÔ∏è API Error: {data['error']['message']}")
        except Exception as e: print(f"‚ùå Error processing message: {e}")

    def handle_authorization(self, data):
        if 'error' in data: print(f"‚ùå Auth failed: {data['error']['message']}"); self.is_running = False
        else: print("‚úÖ Authorized."); self.is_authorized = True; self.state = "ANALYZING"; self.send({'ticks': 'R_75', 'subscribe': 1})
    
    def handle_tick(self, data):
        if 'tick' in data: self.tick_history.append(data['tick']['quote'])

    def handle_proposal(self, data):
        if 'error' in data: return
        proposal = data['proposal']; c_type = data['echo_req']['contract_type']; barrier_key = f"{c_type}_{proposal['id']}"
        self.current_proposals[barrier_key] = {'payout': float(proposal['payout']), 'stake': float(data['echo_req']['amount']), 'barrier': data['echo_req']['barrier']}
        self.send({"buy": proposal['id'], "price": proposal['ask_price'], "passthrough": {"barrier_key": barrier_key}})

    def handle_buy(self, data):
        if 'error' in data: return
        contract_id = data['buy']['contract_id']; barrier_key = data['echo_req']['passthrough']['barrier_key']
        self.active_contracts[contract_id] = self.current_proposals[barrier_key]
        self.send({"proposal_open_contract": 1, "contract_id": contract_id, "subscribe": 1})
        
    def handle_contract_update(self, contract):
        contract_id = contract.get('contract_id')
        if not contract or not contract.get('is_sold') or not self.active_contracts.get(contract_id): return
        trade_details = self.active_contracts[contract_id]; profit = float(contract.get('profit', 0))
        log_entry = {'timestamp_utc': datetime.now(timezone.utc).isoformat(), 'experiment_name': self.experiment['name'], 'trade_pair_id': f"{self.experiment['name']}_{self.trade_pair_id_counter}", **self.last_analysis_data, 'contract_type': contract.get('contract_type'), 'stake': trade_details['stake'], 'barrier': trade_details['barrier'], 'potential_profit': trade_details['payout'] - trade_details['stake'], 'actual_profit': profit, 'result': "WIN" if profit > 0 else "LOSS"}
        self.logger.log_trade(log_entry)
        del self.active_contracts[contract_id]
        if not self.active_contracts: self.trade_in_progress = False

    def run_logic_tick(self):
        if not (self.is_authorized and not self.trade_in_progress and len(self.tick_history) == self.tick_history.maxlen): return

        if self.trade_pair_id_counter < self.experiment['target_trades']:
            self.analyze_market_state(); self.place_trade()
        else:
            self.is_running = False; print(f"\n‚úÖ Experiment '{self.experiment['name']}' complete.")
            
    def analyze_market_state(self):
        ticks = list(self.tick_history); volatility = np.std(ticks); vol_group = "UNKNOWN"
        for group, threshold in VOLATILITY_THRESHOLDS.items():
            if volatility <= threshold: vol_group = group; break
        bb_upper, bb_middle, bb_lower = TechnicalAnalyzer.bollinger_bands(ticks)
        sma_fast = TechnicalAnalyzer.sma(ticks, 5); sma_slow = TechnicalAnalyzer.sma(ticks, 20)
        self.last_analysis_data = {'volatility_score': volatility, 'volatility_group': vol_group, 'trend_sma_fast': sma_fast, 'trend_sma_slow': sma_slow, 'bb_upper': bb_upper, 'bb_middle': bb_middle, 'bb_lower': bb_lower, 'price_position_vs_bands': TechnicalAnalyzer.get_price_position(ticks[-1], (bb_upper, bb_middle, bb_lower))}
            
    def place_trade(self):
        self.trade_in_progress = True; self.trade_pair_id_counter += 1
        self.current_proposals.clear()
        print(f"\r   -> '{self.experiment['name']}': {self.trade_pair_id_counter}/{self.experiment['target_trades']} trades placed...", end="")
        exp_type = self.experiment['type']; params = self.experiment['params']
        base = {"basis": "stake", "currency": "USD", "duration": 5, "duration_unit": "t", "symbol": "R_75"}
        if exp_type == 'HEDGE':
            self.send({**base, "proposal": 1, "contract_type": "ONETOUCH", "amount": params['stake_ot'], "barrier": params['barrier_ot']})
            self.send({**base, "proposal": 1, "contract_type": "NOTOUCH", "amount": params['stake_nt'], "barrier": params['barrier_nt']})
        elif exp_type == 'STRADDLE':
            self.send({**base, "proposal": 1, "contract_type": "ONETOUCH", "amount": params['stake'], "barrier": params['barrier']})
            self.send({**base, "proposal": 1, "contract_type": "ONETOUCH", "amount": params['stake'], "barrier": f"-{params['barrier'][1:]}"})
        elif exp_type == 'CHANNEL':
            self.send({**base, "proposal": 1, "contract_type": "NOTOUCH", "amount": params['stake'], "barrier": params['barrier']})
            self.send({**base, "proposal": 1, "contract_type": "NOTOUCH", "amount": params['stake'], "barrier": f"-{params['barrier'][1:]}"})

# --- Main Execution ---
def main():
    API_KEY = 'LLU4UwUGOCv5Cpq'
    logger = SQLiteLogger()
    
    for i, experiment_config in enumerate(EXPERIMENT_CAMPAIGN):
        print("\n" + "="*80 + f"\nüöÄ Starting Experiment {i+1}/{len(EXPERIMENT_CAMPAIGN)}: '{experiment_config['name']}'\n" + "="*80)
        bot = DerivDataCollectorBot(API_KEY, experiment_config, logger)
        try:
            bot.connect()
            while bot.is_running:
                if not bot.is_connected:
                    if bot.state != "RECONNECTING":
                        bot.state = "RECONNECTING"; print("\nConnection lost. Reconnecting..."); time.sleep(10); bot.connect()
                    else: time.sleep(1)
                else: bot.run_logic_tick(); time.sleep(0.5)
        except KeyboardInterrupt: print("\nüõë Campaign interrupted by user."); break
        finally:
            if bot.ws and bot.is_connected: bot.ws.close()
            print("\n" + "-"*80)
    
    logger.close()
    print(f"\nüéâüéâüéâ CAMPAIGN COMPLETE. Data saved to {logger.db_name} üéâüéâüéâ")

if __name__ == "__main__":
    main()
